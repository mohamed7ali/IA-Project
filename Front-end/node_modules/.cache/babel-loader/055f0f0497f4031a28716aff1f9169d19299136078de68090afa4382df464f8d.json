{"ast":null,"code":"/** @license React vundefined\r\n * react-refresh-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n    var hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\n    // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n    // (unstable) APIs that have been removed. Can we remove the symbols?\n\n    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\n    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\n    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\n    // It's OK to reference families, but use WeakMap/Set for types.\n\n    var allFamiliesByID = new Map();\n    var allFamiliesByType = new PossiblyWeakMap();\n    var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\n    // that have actually been edited here. This keeps checks fast.\n    // $FlowIssue\n\n    var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\n    // It is an array of [Family, NextType] tuples.\n\n    var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\n\n    var helpersByRendererID = new Map();\n    var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\n\n    var mountedRoots = new Set(); // If a root captures an error, we add its element to this Map so we can retry on edit.\n\n    var failedRoots = new Map();\n    var didSomeRootFailOnMount = false;\n    function computeFullKey(signature) {\n      if (signature.fullKey !== null) {\n        return signature.fullKey;\n      }\n      var fullKey = signature.ownKey;\n      var hooks;\n      try {\n        hooks = signature.getCustomHooks();\n      } catch (err) {\n        // This can happen in an edge case, e.g. if expression like Foo.useSomething\n        // depends on Foo which is lazily initialized during rendering.\n        // In that case just assume we'll have to remount.\n        signature.forceReset = true;\n        signature.fullKey = fullKey;\n        return fullKey;\n      }\n      for (var i = 0; i < hooks.length; i++) {\n        var hook = hooks[i];\n        if (typeof hook !== 'function') {\n          // Something's wrong. Assume we need to remount.\n          signature.forceReset = true;\n          signature.fullKey = fullKey;\n          return fullKey;\n        }\n        var nestedHookSignature = allSignaturesByType.get(hook);\n        if (nestedHookSignature === undefined) {\n          // No signature means Hook wasn't in the source code, e.g. in a library.\n          // We'll skip it because we can assume it won't change during this session.\n          continue;\n        }\n        var nestedHookKey = computeFullKey(nestedHookSignature);\n        if (nestedHookSignature.forceReset) {\n          signature.forceReset = true;\n        }\n        fullKey += '\\n---\\n' + nestedHookKey;\n      }\n      signature.fullKey = fullKey;\n      return fullKey;\n    }\n    function haveEqualSignatures(prevType, nextType) {\n      var prevSignature = allSignaturesByType.get(prevType);\n      var nextSignature = allSignaturesByType.get(nextType);\n      if (prevSignature === undefined && nextSignature === undefined) {\n        return true;\n      }\n      if (prevSignature === undefined || nextSignature === undefined) {\n        return false;\n      }\n      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n        return false;\n      }\n      if (nextSignature.forceReset) {\n        return false;\n      }\n      return true;\n    }\n    function isReactClass(type) {\n      return type.prototype && type.prototype.isReactComponent;\n    }\n    function canPreserveStateBetween(prevType, nextType) {\n      if (isReactClass(prevType) || isReactClass(nextType)) {\n        return false;\n      }\n      if (haveEqualSignatures(prevType, nextType)) {\n        return true;\n      }\n      return false;\n    }\n    function resolveFamily(type) {\n      // Only check updated types to keep lookups fast.\n      return updatedFamiliesByType.get(type);\n    }\n    function performReactRefresh() {\n      {\n        if (pendingUpdates.length === 0) {\n          return null;\n        }\n        var staleFamilies = new Set();\n        var updatedFamilies = new Set();\n        var updates = pendingUpdates;\n        pendingUpdates = [];\n        updates.forEach(function (_ref) {\n          var family = _ref[0],\n            nextType = _ref[1];\n          // Now that we got a real edit, we can create associations\n          // that will be read by the React reconciler.\n          var prevType = family.current;\n          updatedFamiliesByType.set(prevType, family);\n          updatedFamiliesByType.set(nextType, family);\n          family.current = nextType; // Determine whether this should be a re-render or a re-mount.\n\n          if (canPreserveStateBetween(prevType, nextType)) {\n            updatedFamilies.add(family);\n          } else {\n            staleFamilies.add(family);\n          }\n        }); // TODO: rename these fields to something more meaningful.\n\n        var update = {\n          updatedFamilies: updatedFamilies,\n          // Families that will re-render preserving state\n          staleFamilies: staleFamilies // Families that will be remounted\n        };\n\n        helpersByRendererID.forEach(function (helpers) {\n          // Even if there are no roots, set the handler on first update.\n          // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n          helpers.setRefreshHandler(resolveFamily);\n        });\n        var didError = false;\n        var firstError = null;\n        failedRoots.forEach(function (element, root) {\n          var helpers = helpersByRoot.get(root);\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n          try {\n            helpers.scheduleRoot(root, element);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            } // Keep trying other roots.\n          }\n        });\n\n        mountedRoots.forEach(function (root) {\n          var helpers = helpersByRoot.get(root);\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n          try {\n            helpers.scheduleRefresh(root, update);\n          } catch (err) {\n            if (!didError) {\n              didError = true;\n              firstError = err;\n            } // Keep trying other roots.\n          }\n        });\n\n        if (didError) {\n          throw firstError;\n        }\n        return update;\n      }\n    }\n    function register(type, id) {\n      {\n        if (type === null) {\n          return;\n        }\n        if (typeof type !== 'function' && typeof type !== 'object') {\n          return;\n        } // This can happen in an edge case, e.g. if we register\n        // return value of a HOC but it returns a cached component.\n        // Ignore anything but the first registration for each type.\n\n        if (allFamiliesByType.has(type)) {\n          return;\n        } // Create family or remember to update it.\n        // None of this bookkeeping affects reconciliation\n        // until the first performReactRefresh() call above.\n\n        var family = allFamiliesByID.get(id);\n        if (family === undefined) {\n          family = {\n            current: type\n          };\n          allFamiliesByID.set(id, family);\n        } else {\n          pendingUpdates.push([family, type]);\n        }\n        allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\n\n        if (typeof type === 'object' && type !== null) {\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              register(type.render, id + '$render');\n              break;\n            case REACT_MEMO_TYPE:\n              register(type.type, id + '$type');\n              break;\n          }\n        }\n      }\n    }\n    function setSignature(type, key) {\n      var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\n      {\n        allSignaturesByType.set(type, {\n          forceReset: forceReset,\n          ownKey: key,\n          fullKey: null,\n          getCustomHooks: getCustomHooks || function () {\n            return [];\n          }\n        });\n      }\n    } // This is lazily called during first render for a type.\n    // It captures Hook list at that time so inline requires don't break comparisons.\n\n    function collectCustomHooksForSignature(type) {\n      {\n        var signature = allSignaturesByType.get(type);\n        if (signature !== undefined) {\n          computeFullKey(signature);\n        }\n      }\n    }\n    function getFamilyByID(id) {\n      {\n        return allFamiliesByID.get(id);\n      }\n    }\n    function getFamilyByType(type) {\n      {\n        return allFamiliesByType.get(type);\n      }\n    }\n    function findAffectedHostInstances(families) {\n      {\n        var affectedInstances = new Set();\n        mountedRoots.forEach(function (root) {\n          var helpers = helpersByRoot.get(root);\n          if (helpers === undefined) {\n            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\n          }\n          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\n          instancesForRoot.forEach(function (inst) {\n            affectedInstances.add(inst);\n          });\n        });\n        return affectedInstances;\n      }\n    }\n    function injectIntoGlobalHook(globalObject) {\n      {\n        // For React Native, the global hook will be set up by require('react-devtools-core').\n        // That code will run before us. So we need to monkeypatch functions on existing hook.\n        // For React Web, the global hook will be set up by the extension.\n        // This will also run before us.\n        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook === undefined) {\n          // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n          // Note that in this case it's important that renderer code runs *after* this method call.\n          // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n          var nextID = 0;\n          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n            supportsFiber: true,\n            inject: function (injected) {\n              return nextID++;\n            },\n            onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\n            onCommitFiberUnmount: function () {}\n          };\n        } // Here, we just want to get a reference to scheduleRefresh.\n\n        var oldInject = hook.inject;\n        hook.inject = function (injected) {\n          var id = oldInject.apply(this, arguments);\n          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\n            // This version supports React Refresh.\n            helpersByRendererID.set(id, injected);\n          }\n          return id;\n        }; // We also want to track currently mounted roots.\n\n        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\n        hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n          var helpers = helpersByRendererID.get(id);\n          if (helpers === undefined) {\n            return;\n          }\n          helpersByRoot.set(root, helpers);\n          var current = root.current;\n          var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\n          // This logic is copy-pasted from similar logic in the DevTools backend.\n          // If this breaks with some refactoring, you'll want to update DevTools too.\n\n          if (alternate !== null) {\n            var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\n            var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n            if (!wasMounted && isMounted) {\n              // Mount a new root.\n              mountedRoots.add(root);\n              failedRoots.delete(root);\n            } else if (wasMounted && isMounted) {// Update an existing root.\n              // This doesn't affect our mounted root Set.\n            } else if (wasMounted && !isMounted) {\n              // Unmount an existing root.\n              mountedRoots.delete(root);\n              if (didError) {\n                // We'll remount it on future edits.\n                // Remember what was rendered so we can restore it.\n                failedRoots.set(root, alternate.memoizedState.element);\n              } else {\n                helpersByRoot.delete(root);\n              }\n            } else if (!wasMounted && !isMounted) {\n              if (didError && !failedRoots.has(root)) {\n                // The root had an error during the initial mount.\n                // We can't read its last element from the memoized state\n                // because there was no previously committed alternate.\n                // Ideally, it would be nice if we had a way to extract\n                // the last attempted rendered element, but accessing the update queue\n                // would tie this package too closely to the reconciler version.\n                // So instead, we just set a flag.\n                // TODO: Maybe we could fix this as the same time as when we fix\n                // DevTools to not depend on `alternate.memoizedState.element`.\n                didSomeRootFailOnMount = true;\n              }\n            }\n          } else {\n            // Mount a new root.\n            mountedRoots.add(root);\n          }\n          return oldOnCommitFiberRoot.apply(this, arguments);\n        };\n      }\n    }\n    function hasUnrecoverableErrors() {\n      return didSomeRootFailOnMount;\n    } // Exposed for testing.\n\n    function _getMountedRootCount() {\n      {\n        return mountedRoots.size;\n      }\n    } // This is a wrapper over more primitive functions for setting signature.\n    // Signatures let us decide whether the Hook order has changed on refresh.\n    //\n    // This function is intended to be used as a transform target, e.g.:\n    // var _s = createSignatureFunctionForTransform()\n    //\n    // function Hello() {\n    //   const [foo, setFoo] = useState(0);\n    //   const value = useCustomHook();\n    //   _s(); /* Second call triggers collecting the custom Hook list.\n    //          * This doesn't happen during the module evaluation because we\n    //          * don't want to change the module order with inline requires.\n    //          * Next calls are noops. */\n    //   return <h1>Hi</h1>;\n    // }\n    //\n    // /* First call specifies the signature: */\n    // _s(\n    //   Hello,\n    //   'useState{[foo, setFoo]}(0)',\n    //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n    // );\n\n    function createSignatureFunctionForTransform() {\n      {\n        // We'll fill in the signature in two steps.\n        // First, we'll know the signature itself. This happens outside the component.\n        // Then, we'll know the references to custom Hooks. This happens inside the component.\n        // After that, the returned function will be a fast path no-op.\n        var status = 'needsSignature';\n        var savedType;\n        var hasCustomHooks;\n        return function (type, key, forceReset, getCustomHooks) {\n          switch (status) {\n            case 'needsSignature':\n              if (type !== undefined) {\n                // If we received an argument, this is the initial registration call.\n                savedType = type;\n                hasCustomHooks = typeof getCustomHooks === 'function';\n                setSignature(type, key, forceReset, getCustomHooks); // The next call we expect is from inside a function, to fill in the custom Hooks.\n\n                status = 'needsCustomHooks';\n              }\n              break;\n            case 'needsCustomHooks':\n              if (hasCustomHooks) {\n                collectCustomHooksForSignature(savedType);\n              }\n              status = 'resolved';\n              break;\n            case 'resolved':\n              // Do nothing. Fast path for all future renders.\n              break;\n          }\n          return type;\n        };\n      }\n    }\n    function isLikelyComponentType(type) {\n      {\n        switch (typeof type) {\n          case 'function':\n            {\n              // First, deal with classes.\n              if (type.prototype != null) {\n                if (type.prototype.isReactComponent) {\n                  // React class.\n                  return true;\n                }\n                var ownNames = Object.getOwnPropertyNames(type.prototype);\n                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n                  // This looks like a class.\n                  return false;\n                } // eslint-disable-next-line no-proto\n\n                if (type.prototype.__proto__ !== Object.prototype) {\n                  // It has a superclass.\n                  return false;\n                } // Pass through.\n                // This looks like a regular function with empty prototype.\n              } // For plain functions and arrows, use name as a heuristic.\n\n              var name = type.name || type.displayName;\n              return typeof name === 'string' && /^[A-Z]/.test(name);\n            }\n          case 'object':\n            {\n              if (type != null) {\n                switch (type.$$typeof) {\n                  case REACT_FORWARD_REF_TYPE:\n                  case REACT_MEMO_TYPE:\n                    // Definitely React components.\n                    return true;\n                  default:\n                    return false;\n                }\n              }\n              return false;\n            }\n          default:\n            {\n              return false;\n            }\n        }\n      }\n    }\n    var ReactFreshRuntime = Object.freeze({\n      performReactRefresh: performReactRefresh,\n      register: register,\n      setSignature: setSignature,\n      collectCustomHooksForSignature: collectCustomHooksForSignature,\n      getFamilyByID: getFamilyByID,\n      getFamilyByType: getFamilyByType,\n      findAffectedHostInstances: findAffectedHostInstances,\n      injectIntoGlobalHook: injectIntoGlobalHook,\n      hasUnrecoverableErrors: hasUnrecoverableErrors,\n      _getMountedRootCount: _getMountedRootCount,\n      createSignatureFunctionForTransform: createSignatureFunctionForTransform,\n      isLikelyComponentType: isLikelyComponentType\n    });\n\n    // This is hacky but makes it work with both Rollup and Jest.\n\n    var runtime = ReactFreshRuntime.default || ReactFreshRuntime;\n    module.exports = runtime;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","hasSymbol","Symbol","for","REACT_FORWARD_REF_TYPE","REACT_MEMO_TYPE","PossiblyWeakMap","WeakMap","Map","allFamiliesByID","allFamiliesByType","allSignaturesByType","updatedFamiliesByType","pendingUpdates","helpersByRendererID","helpersByRoot","mountedRoots","Set","failedRoots","didSomeRootFailOnMount","computeFullKey","signature","fullKey","ownKey","hooks","getCustomHooks","err","forceReset","i","length","hook","nestedHookSignature","get","undefined","nestedHookKey","haveEqualSignatures","prevType","nextType","prevSignature","nextSignature","isReactClass","type","prototype","isReactComponent","canPreserveStateBetween","resolveFamily","performReactRefresh","staleFamilies","updatedFamilies","updates","forEach","_ref","family","current","set","add","update","helpers","setRefreshHandler","didError","firstError","element","root","Error","scheduleRoot","scheduleRefresh","register","id","has","push","$$typeof","render","setSignature","key","arguments","collectCustomHooksForSignature","getFamilyByID","getFamilyByType","findAffectedHostInstances","families","affectedInstances","instancesForRoot","findHostInstancesForRefresh","inst","injectIntoGlobalHook","globalObject","__REACT_DEVTOOLS_GLOBAL_HOOK__","nextID","supportsFiber","inject","injected","onCommitFiberRoot","maybePriorityLevel","onCommitFiberUnmount","oldInject","apply","oldOnCommitFiberRoot","alternate","wasMounted","memoizedState","isMounted","delete","hasUnrecoverableErrors","_getMountedRootCount","size","createSignatureFunctionForTransform","status","savedType","hasCustomHooks","isLikelyComponentType","ownNames","Object","getOwnPropertyNames","__proto__","name","displayName","test","ReactFreshRuntime","freeze","runtime","default","module","exports"],"sources":["D:/IAAA/IA-Project/Front-end/node_modules/react-refresh/cjs/react-refresh-runtime.development.js"],"sourcesContent":["/** @license React vundefined\r\n * react-refresh-runtime.development.js\r\n *\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n'use strict';\r\n\r\n\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  (function() {\r\n'use strict';\r\n\r\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\r\n// nor polyfill, then a plain number is used for performance.\r\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\r\n\r\n\r\n\r\n\r\n\r\n\r\n // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\r\n// (unstable) APIs that have been removed. Can we remove the symbols?\r\n\r\n\r\n\r\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\r\n\r\n\r\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\r\n\r\nvar PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.\r\n// It's OK to reference families, but use WeakMap/Set for types.\r\n\r\nvar allFamiliesByID = new Map();\r\nvar allFamiliesByType = new PossiblyWeakMap();\r\nvar allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families\r\n// that have actually been edited here. This keeps checks fast.\r\n// $FlowIssue\r\n\r\nvar updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.\r\n// It is an array of [Family, NextType] tuples.\r\n\r\nvar pendingUpdates = []; // This is injected by the renderer via DevTools global hook.\r\n\r\nvar helpersByRendererID = new Map();\r\nvar helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.\r\n\r\nvar mountedRoots = new Set(); // If a root captures an error, we add its element to this Map so we can retry on edit.\r\n\r\nvar failedRoots = new Map();\r\nvar didSomeRootFailOnMount = false;\r\n\r\nfunction computeFullKey(signature) {\r\n  if (signature.fullKey !== null) {\r\n    return signature.fullKey;\r\n  }\r\n\r\n  var fullKey = signature.ownKey;\r\n  var hooks;\r\n\r\n  try {\r\n    hooks = signature.getCustomHooks();\r\n  } catch (err) {\r\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\r\n    // depends on Foo which is lazily initialized during rendering.\r\n    // In that case just assume we'll have to remount.\r\n    signature.forceReset = true;\r\n    signature.fullKey = fullKey;\r\n    return fullKey;\r\n  }\r\n\r\n  for (var i = 0; i < hooks.length; i++) {\r\n    var hook = hooks[i];\r\n\r\n    if (typeof hook !== 'function') {\r\n      // Something's wrong. Assume we need to remount.\r\n      signature.forceReset = true;\r\n      signature.fullKey = fullKey;\r\n      return fullKey;\r\n    }\r\n\r\n    var nestedHookSignature = allSignaturesByType.get(hook);\r\n\r\n    if (nestedHookSignature === undefined) {\r\n      // No signature means Hook wasn't in the source code, e.g. in a library.\r\n      // We'll skip it because we can assume it won't change during this session.\r\n      continue;\r\n    }\r\n\r\n    var nestedHookKey = computeFullKey(nestedHookSignature);\r\n\r\n    if (nestedHookSignature.forceReset) {\r\n      signature.forceReset = true;\r\n    }\r\n\r\n    fullKey += '\\n---\\n' + nestedHookKey;\r\n  }\r\n\r\n  signature.fullKey = fullKey;\r\n  return fullKey;\r\n}\r\n\r\nfunction haveEqualSignatures(prevType, nextType) {\r\n  var prevSignature = allSignaturesByType.get(prevType);\r\n  var nextSignature = allSignaturesByType.get(nextType);\r\n\r\n  if (prevSignature === undefined && nextSignature === undefined) {\r\n    return true;\r\n  }\r\n\r\n  if (prevSignature === undefined || nextSignature === undefined) {\r\n    return false;\r\n  }\r\n\r\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\r\n    return false;\r\n  }\r\n\r\n  if (nextSignature.forceReset) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction isReactClass(type) {\r\n  return type.prototype && type.prototype.isReactComponent;\r\n}\r\n\r\nfunction canPreserveStateBetween(prevType, nextType) {\r\n  if (isReactClass(prevType) || isReactClass(nextType)) {\r\n    return false;\r\n  }\r\n\r\n  if (haveEqualSignatures(prevType, nextType)) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction resolveFamily(type) {\r\n  // Only check updated types to keep lookups fast.\r\n  return updatedFamiliesByType.get(type);\r\n}\r\n\r\nfunction performReactRefresh() {\r\n  {\r\n    if (pendingUpdates.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    var staleFamilies = new Set();\r\n    var updatedFamilies = new Set();\r\n    var updates = pendingUpdates;\r\n    pendingUpdates = [];\r\n    updates.forEach(function (_ref) {\r\n      var family = _ref[0],\r\n          nextType = _ref[1];\r\n      // Now that we got a real edit, we can create associations\r\n      // that will be read by the React reconciler.\r\n      var prevType = family.current;\r\n      updatedFamiliesByType.set(prevType, family);\r\n      updatedFamiliesByType.set(nextType, family);\r\n      family.current = nextType; // Determine whether this should be a re-render or a re-mount.\r\n\r\n      if (canPreserveStateBetween(prevType, nextType)) {\r\n        updatedFamilies.add(family);\r\n      } else {\r\n        staleFamilies.add(family);\r\n      }\r\n    }); // TODO: rename these fields to something more meaningful.\r\n\r\n    var update = {\r\n      updatedFamilies: updatedFamilies,\r\n      // Families that will re-render preserving state\r\n      staleFamilies: staleFamilies // Families that will be remounted\r\n\r\n    };\r\n    helpersByRendererID.forEach(function (helpers) {\r\n      // Even if there are no roots, set the handler on first update.\r\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\r\n      helpers.setRefreshHandler(resolveFamily);\r\n    });\r\n    var didError = false;\r\n    var firstError = null;\r\n    failedRoots.forEach(function (element, root) {\r\n      var helpers = helpersByRoot.get(root);\r\n\r\n      if (helpers === undefined) {\r\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\r\n      }\r\n\r\n      try {\r\n        helpers.scheduleRoot(root, element);\r\n      } catch (err) {\r\n        if (!didError) {\r\n          didError = true;\r\n          firstError = err;\r\n        } // Keep trying other roots.\r\n\r\n      }\r\n    });\r\n    mountedRoots.forEach(function (root) {\r\n      var helpers = helpersByRoot.get(root);\r\n\r\n      if (helpers === undefined) {\r\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\r\n      }\r\n\r\n      try {\r\n        helpers.scheduleRefresh(root, update);\r\n      } catch (err) {\r\n        if (!didError) {\r\n          didError = true;\r\n          firstError = err;\r\n        } // Keep trying other roots.\r\n\r\n      }\r\n    });\r\n\r\n    if (didError) {\r\n      throw firstError;\r\n    }\r\n\r\n    return update;\r\n  }\r\n}\r\nfunction register(type, id) {\r\n  {\r\n    if (type === null) {\r\n      return;\r\n    }\r\n\r\n    if (typeof type !== 'function' && typeof type !== 'object') {\r\n      return;\r\n    } // This can happen in an edge case, e.g. if we register\r\n    // return value of a HOC but it returns a cached component.\r\n    // Ignore anything but the first registration for each type.\r\n\r\n\r\n    if (allFamiliesByType.has(type)) {\r\n      return;\r\n    } // Create family or remember to update it.\r\n    // None of this bookkeeping affects reconciliation\r\n    // until the first performReactRefresh() call above.\r\n\r\n\r\n    var family = allFamiliesByID.get(id);\r\n\r\n    if (family === undefined) {\r\n      family = {\r\n        current: type\r\n      };\r\n      allFamiliesByID.set(id, family);\r\n    } else {\r\n      pendingUpdates.push([family, type]);\r\n    }\r\n\r\n    allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.\r\n\r\n    if (typeof type === 'object' && type !== null) {\r\n      switch (type.$$typeof) {\r\n        case REACT_FORWARD_REF_TYPE:\r\n          register(type.render, id + '$render');\r\n          break;\r\n\r\n        case REACT_MEMO_TYPE:\r\n          register(type.type, id + '$type');\r\n          break;\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction setSignature(type, key) {\r\n  var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n  var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;\r\n\r\n  {\r\n    allSignaturesByType.set(type, {\r\n      forceReset: forceReset,\r\n      ownKey: key,\r\n      fullKey: null,\r\n      getCustomHooks: getCustomHooks || function () {\r\n        return [];\r\n      }\r\n    });\r\n  }\r\n} // This is lazily called during first render for a type.\r\n// It captures Hook list at that time so inline requires don't break comparisons.\r\n\r\nfunction collectCustomHooksForSignature(type) {\r\n  {\r\n    var signature = allSignaturesByType.get(type);\r\n\r\n    if (signature !== undefined) {\r\n      computeFullKey(signature);\r\n    }\r\n  }\r\n}\r\nfunction getFamilyByID(id) {\r\n  {\r\n    return allFamiliesByID.get(id);\r\n  }\r\n}\r\nfunction getFamilyByType(type) {\r\n  {\r\n    return allFamiliesByType.get(type);\r\n  }\r\n}\r\nfunction findAffectedHostInstances(families) {\r\n  {\r\n    var affectedInstances = new Set();\r\n    mountedRoots.forEach(function (root) {\r\n      var helpers = helpersByRoot.get(root);\r\n\r\n      if (helpers === undefined) {\r\n        throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');\r\n      }\r\n\r\n      var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);\r\n      instancesForRoot.forEach(function (inst) {\r\n        affectedInstances.add(inst);\r\n      });\r\n    });\r\n    return affectedInstances;\r\n  }\r\n}\r\nfunction injectIntoGlobalHook(globalObject) {\r\n  {\r\n    // For React Native, the global hook will be set up by require('react-devtools-core').\r\n    // That code will run before us. So we need to monkeypatch functions on existing hook.\r\n    // For React Web, the global hook will be set up by the extension.\r\n    // This will also run before us.\r\n    var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;\r\n\r\n    if (hook === undefined) {\r\n      // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\r\n      // Note that in this case it's important that renderer code runs *after* this method call.\r\n      // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\r\n      var nextID = 0;\r\n      globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\r\n        supportsFiber: true,\r\n        inject: function (injected) {\r\n          return nextID++;\r\n        },\r\n        onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},\r\n        onCommitFiberUnmount: function () {}\r\n      };\r\n    } // Here, we just want to get a reference to scheduleRefresh.\r\n\r\n\r\n    var oldInject = hook.inject;\r\n\r\n    hook.inject = function (injected) {\r\n      var id = oldInject.apply(this, arguments);\r\n\r\n      if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {\r\n        // This version supports React Refresh.\r\n        helpersByRendererID.set(id, injected);\r\n      }\r\n\r\n      return id;\r\n    }; // We also want to track currently mounted roots.\r\n\r\n\r\n    var oldOnCommitFiberRoot = hook.onCommitFiberRoot;\r\n\r\n    hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\r\n      var helpers = helpersByRendererID.get(id);\r\n\r\n      if (helpers === undefined) {\r\n        return;\r\n      }\r\n\r\n      helpersByRoot.set(root, helpers);\r\n      var current = root.current;\r\n      var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.\r\n      // This logic is copy-pasted from similar logic in the DevTools backend.\r\n      // If this breaks with some refactoring, you'll want to update DevTools too.\r\n\r\n      if (alternate !== null) {\r\n        var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\r\n        var isMounted = current.memoizedState != null && current.memoizedState.element != null;\r\n\r\n        if (!wasMounted && isMounted) {\r\n          // Mount a new root.\r\n          mountedRoots.add(root);\r\n          failedRoots.delete(root);\r\n        } else if (wasMounted && isMounted) {// Update an existing root.\r\n          // This doesn't affect our mounted root Set.\r\n        } else if (wasMounted && !isMounted) {\r\n          // Unmount an existing root.\r\n          mountedRoots.delete(root);\r\n\r\n          if (didError) {\r\n            // We'll remount it on future edits.\r\n            // Remember what was rendered so we can restore it.\r\n            failedRoots.set(root, alternate.memoizedState.element);\r\n          } else {\r\n            helpersByRoot.delete(root);\r\n          }\r\n        } else if (!wasMounted && !isMounted) {\r\n          if (didError && !failedRoots.has(root)) {\r\n            // The root had an error during the initial mount.\r\n            // We can't read its last element from the memoized state\r\n            // because there was no previously committed alternate.\r\n            // Ideally, it would be nice if we had a way to extract\r\n            // the last attempted rendered element, but accessing the update queue\r\n            // would tie this package too closely to the reconciler version.\r\n            // So instead, we just set a flag.\r\n            // TODO: Maybe we could fix this as the same time as when we fix\r\n            // DevTools to not depend on `alternate.memoizedState.element`.\r\n            didSomeRootFailOnMount = true;\r\n          }\r\n        }\r\n      } else {\r\n        // Mount a new root.\r\n        mountedRoots.add(root);\r\n      }\r\n\r\n      return oldOnCommitFiberRoot.apply(this, arguments);\r\n    };\r\n  }\r\n}\r\nfunction hasUnrecoverableErrors() {\r\n  return didSomeRootFailOnMount;\r\n} // Exposed for testing.\r\n\r\nfunction _getMountedRootCount() {\r\n  {\r\n    return mountedRoots.size;\r\n  }\r\n} // This is a wrapper over more primitive functions for setting signature.\r\n// Signatures let us decide whether the Hook order has changed on refresh.\r\n//\r\n// This function is intended to be used as a transform target, e.g.:\r\n// var _s = createSignatureFunctionForTransform()\r\n//\r\n// function Hello() {\r\n//   const [foo, setFoo] = useState(0);\r\n//   const value = useCustomHook();\r\n//   _s(); /* Second call triggers collecting the custom Hook list.\r\n//          * This doesn't happen during the module evaluation because we\r\n//          * don't want to change the module order with inline requires.\r\n//          * Next calls are noops. */\r\n//   return <h1>Hi</h1>;\r\n// }\r\n//\r\n// /* First call specifies the signature: */\r\n// _s(\r\n//   Hello,\r\n//   'useState{[foo, setFoo]}(0)',\r\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\r\n// );\r\n\r\nfunction createSignatureFunctionForTransform() {\r\n  {\r\n    // We'll fill in the signature in two steps.\r\n    // First, we'll know the signature itself. This happens outside the component.\r\n    // Then, we'll know the references to custom Hooks. This happens inside the component.\r\n    // After that, the returned function will be a fast path no-op.\r\n    var status = 'needsSignature';\r\n    var savedType;\r\n    var hasCustomHooks;\r\n    return function (type, key, forceReset, getCustomHooks) {\r\n      switch (status) {\r\n        case 'needsSignature':\r\n          if (type !== undefined) {\r\n            // If we received an argument, this is the initial registration call.\r\n            savedType = type;\r\n            hasCustomHooks = typeof getCustomHooks === 'function';\r\n            setSignature(type, key, forceReset, getCustomHooks); // The next call we expect is from inside a function, to fill in the custom Hooks.\r\n\r\n            status = 'needsCustomHooks';\r\n          }\r\n\r\n          break;\r\n\r\n        case 'needsCustomHooks':\r\n          if (hasCustomHooks) {\r\n            collectCustomHooksForSignature(savedType);\r\n          }\r\n\r\n          status = 'resolved';\r\n          break;\r\n\r\n        case 'resolved':\r\n          // Do nothing. Fast path for all future renders.\r\n          break;\r\n      }\r\n\r\n      return type;\r\n    };\r\n  }\r\n}\r\nfunction isLikelyComponentType(type) {\r\n  {\r\n    switch (typeof type) {\r\n      case 'function':\r\n        {\r\n          // First, deal with classes.\r\n          if (type.prototype != null) {\r\n            if (type.prototype.isReactComponent) {\r\n              // React class.\r\n              return true;\r\n            }\r\n\r\n            var ownNames = Object.getOwnPropertyNames(type.prototype);\r\n\r\n            if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\r\n              // This looks like a class.\r\n              return false;\r\n            } // eslint-disable-next-line no-proto\r\n\r\n\r\n            if (type.prototype.__proto__ !== Object.prototype) {\r\n              // It has a superclass.\r\n              return false;\r\n            } // Pass through.\r\n            // This looks like a regular function with empty prototype.\r\n\r\n          } // For plain functions and arrows, use name as a heuristic.\r\n\r\n\r\n          var name = type.name || type.displayName;\r\n          return typeof name === 'string' && /^[A-Z]/.test(name);\r\n        }\r\n\r\n      case 'object':\r\n        {\r\n          if (type != null) {\r\n            switch (type.$$typeof) {\r\n              case REACT_FORWARD_REF_TYPE:\r\n              case REACT_MEMO_TYPE:\r\n                // Definitely React components.\r\n                return true;\r\n\r\n              default:\r\n                return false;\r\n            }\r\n          }\r\n\r\n          return false;\r\n        }\r\n\r\n      default:\r\n        {\r\n          return false;\r\n        }\r\n    }\r\n  }\r\n}\r\n\r\nvar ReactFreshRuntime = Object.freeze({\r\n\tperformReactRefresh: performReactRefresh,\r\n\tregister: register,\r\n\tsetSignature: setSignature,\r\n\tcollectCustomHooksForSignature: collectCustomHooksForSignature,\r\n\tgetFamilyByID: getFamilyByID,\r\n\tgetFamilyByType: getFamilyByType,\r\n\tfindAffectedHostInstances: findAffectedHostInstances,\r\n\tinjectIntoGlobalHook: injectIntoGlobalHook,\r\n\thasUnrecoverableErrors: hasUnrecoverableErrors,\r\n\t_getMountedRootCount: _getMountedRootCount,\r\n\tcreateSignatureFunctionForTransform: createSignatureFunctionForTransform,\r\n\tisLikelyComponentType: isLikelyComponentType\r\n});\r\n\r\n// This is hacky but makes it work with both Rollup and Jest.\r\n\r\n\r\nvar runtime = ReactFreshRuntime.default || ReactFreshRuntime;\r\n\r\nmodule.exports = runtime;\r\n  })();\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}